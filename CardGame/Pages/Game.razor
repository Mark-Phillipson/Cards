@page "/stripjacknaked"
@using System.Linq
@using System.Threading.Tasks
@using CardGame.Models
@using CardGame.Services
@inject DeckService DeckService
@inject IJSRuntime JS

<h3>Strip Jack Naked</h3>

<style>
    /* Animated CPU card moving to center */
    .animated-card {
        position: absolute;
        top: 40px;
        /* start slightly smaller for animation */
        height: 120px;
        /* CPU will start from the left side */
        left: 15%;
        transition: left 600ms ease, height 600ms ease, transform 600ms ease, opacity 300ms ease;
        z-index: 60;
        transform: rotate(0deg);
        box-shadow:0 6px 12px rgba(0,0,0,0.25);
    }
    .animated-card.to-center {
    left: 50%;
    transform: translateX(-50%) rotate(-20deg);
        height: 160px;
    }
    /* Player animated card starts from right and moves to center */
    .animated-card.player { left: 85%; }
    .animated-card.player.to-center { left: 50%; transform: translateX(-50%) rotate(20deg); height:160px; }
    /* Penalty color classes: 1..4 */
    .penalty-1 { background:#dc3545; color:#fff; } /* red */
    .penalty-2 { background:#fd7e14; color:#fff; } /* orange */
    .penalty-3 { background:#ffc107; color:#000; } /* yellow */
    .penalty-4 { background:#198754; color:#fff; } /* green */
    /* Pile-to-hand animation: centered -> move left or right */
    .pile-anim {
        position: absolute;
        left: 50%;
        top: 40px;
        transform: translateX(-50%) rotate(4deg) scale(1);
        height:160px;
        transition: transform 700ms cubic-bezier(.2,.9,.2,1), opacity 300ms ease;
        z-index: 80;
    }
    .pile-anim.to-left { transform: translateX(-250%) rotate(-8deg) scale(0.9); }
    .pile-anim.to-right { transform: translateX(150%) rotate(8deg) scale(0.9); }
</style>

<div class="mb-3">
    <button class="btn btn-primary me-2" @onclick="StartGame" @ref="startButton">Start Game</button>
    <button class="btn btn-secondary me-2" @onclick="ResetGame">Reset Game</button>
    <button class="btn btn-success" @onclick="HumanPlay" disabled="@(!IsHumanTurn || GameOver || !CanPlay)" @ref="playButton">Play Card</button>
    @statusMessage
</div>

<div class="row">

    <div class="col-md-4" style="@(CurrentPlayerIndex==0 ? "background:#f8f9fa;border-radius:6px;" : "")">
        @if (Players.Count > 0)
        {
            var isPenalized0 = PenaltyActive && PenaltyPlayerIndex.HasValue && PenaltyPlayerIndex.Value == 0;
            <h5>
                @Players[0].Name
                @(CurrentPlayerIndex==0 ? " ⬅️ Your turn" : "")
                @if (isPenalized0)
                {
                    <span class="badge ms-2 @PenaltyBadgeClass(PenaltyCount)" style="font-size:1.15rem; padding:0.45rem 0.6rem;">@PenaltyCount</span>
                }
            </h5>
        }
        else
        {
            <h5>Player 1 (empty)</h5>
        }
    <!-- deck graphic removed for player 1 per UI update; keep spacer for layout -->
    
        @* next human card (top of their deck) *@
        <div style="margin-top:6px;">
                @{
                    var next = GetNextCardForPlayer(0);
                    if (next != null)
                    {
                        /* Show the human's top card face-up (right-aligned) so they can see it before playing */
                        <div style="display:flex; justify-content:flex-end;">
                            <img src="@next.ImageUrl" alt="@next.Rank of @next.Suit" style="height:160px; box-shadow:0 4px 6px rgba(0,0,0,0.15);" />
                        </div>
                    }
                    else
                    {
                        <div style="display:flex; justify-content:flex-end;">
                            <img src="/cards/Cards-Blank.svg" alt="no-card" style="height:160px;" />
                        </div>
                    }
                }
        </div>

        @* progress meter showing player's share of the total cards (players' decks + pile) *@
        @if (Players.Count > 0)
        {
            var total = TotalCardsCount;
            var pct = total == 0 ? 0 : (int)Math.Round(100.0 * (Players[0].Deck?.Count ?? 0) / total);
            <div class="mt-2" style="width:100%;">
                <div class="progress" style="height:12px; background:#e9ecef; border-radius:6px;">
                    <div class="progress-bar" role="progressbar" style="width:@pct%; background:#0d6efd;" aria-valuenow="@pct" aria-valuemin="0" aria-valuemax="100">
                        <span class="visually-hidden">@pct% of cards</span>
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="col-md-4 text-center">
        <h5>Center Pile (@Pile.Count)</h5>
        <div style="position:relative; height:200px;">
        @if (Pile.Count > 0)
        {
            var arr = Pile.ToArray();
            // top card is arr[0] since Stack.ToArray returns LIFO; show only top
            var top = arr.Length > 0 ? arr[0] : null;
            if (top != null)
            {
                var rotateDeg = (LastPlayedByIndex == 0) ? -20 : 20;
                <img src="@top.ImageUrl" alt="@top.Rank of @top.Suit" style="@($"height:160px; position:absolute; left:50%; transform:translateX(-50%) rotate({rotateDeg}deg); top:40px; box-shadow:0 6px 12px rgba(0,0,0,0.25); opacity:1;")" />
            }
        }
        else
        {
            <img src="/cards/Cards-Blank.svg" alt="empty" style="height:160px;" />
        }
        @* Animated CPU card overlays *@
        @if (IsAnimatingCpuCard && !string.IsNullOrEmpty(AnimCpuCardUrl))
        {
            <img src="@AnimCpuCardUrl" class="animated-card player @(AnimCpuToCenter ? "to-center" : "")" style="opacity:1;" />
        }
        @if (IsAnimatingPlayerCard && !string.IsNullOrEmpty(AnimPlayerCardUrl))
        {
            <img src="@AnimPlayerCardUrl" class="animated-card @(AnimPlayerToCenter ? "to-center" : "")" style="opacity:1;" />
        }
        @if (IsAnimatingTakePile && AnimPileCards != null && AnimPileCards.Length > 0)
        {
            var top = AnimPileCards.Length > 0 ? AnimPileCards[0] : null;
            if (top != null)
            {
                var cls = "pile-anim" + (TakePileTargetIndex == 0 ? " to-left" : (TakePileTargetIndex == 1 ? " to-right" : ""));
                <img src="@top.ImageUrl" class="@cls" style="opacity:1;" />
            }
        }
        </div>
    </div>

    <div class="col-md-4 text-end" style="@(CurrentPlayerIndex==1 ? "background:#f8f9fa;border-radius:6px;" : "")">
        @if (Players.Count > 1)
        {
            var isPenalized1 = PenaltyActive && PenaltyPlayerIndex.HasValue && PenaltyPlayerIndex.Value == 1;
            <h5>
                @Players[1].Name
                @(CurrentPlayerIndex==1 ? " ⬅️ Their turn" : "")
                @if (isPenalized1)
                {
                    <span class="badge ms-2 @PenaltyBadgeClass(PenaltyCount)" style="font-size:1.15rem; padding:0.45rem 0.6rem;">@PenaltyCount</span>
                }
            </h5>
        }
        else
        {
            <h5>Player 2 (CPU)</h5>
        }
        @* single CPU card (back) shown left-aligned; no duplicate deck preview *@
        <div style="margin-top:6px; display:flex; justify-content:flex-start;">
            @{ 
                var nextCpu = GetNextCardForPlayer(1);
                if (nextCpu != null)
                {
                    <img src="/cards/Cards-Reverse.svg" alt="face-down" style="height:160px; box-shadow:0 4px 6px rgba(0,0,0,0.15);" />
                }
                else
                {
                    <img src="/cards/Cards-Blank.svg" alt="no-card" style="height:160px;" />
                }
            }
        </div>

        @* progress meter for player 2 (CPU) *@
        @if (Players.Count > 1)
        {
            var total = TotalCardsCount;
            var pct2 = total == 0 ? 0 : (int)Math.Round(100.0 * (Players[1].Deck?.Count ?? 0) / total);
            <div class="mt-2" style="width:100%;">
                <div class="progress" style="height:12px; background:#e9ecef; border-radius:6px;">
                    <div class="progress-bar" role="progressbar" style="width:@pct2%; background:#198754;" aria-valuenow="@pct2" aria-valuemin="0" aria-valuemax="100">
                        <span class="visually-hidden">@pct2% of cards</span>
                    </div>
                </div>
            </div>
        }
    </div>
</div>

@if (GameOver)
{
    <div class="alert alert-success mt-3">@winnerMessage</div>
}

@code {
    // ...existing code...
    private List<Player> Players = new();
    private Stack<Card> Pile = new();
    private int CurrentPlayerIndex = 0; // 0 = human, 1 = CPU
    private int PenaltyCount = 0;
    private bool PenaltyActive = false;
    private int? PenaltyPlayerIndex = null; // which player must play penalty cards
    private Player? LastCourtPlayer = null;
    private bool CanPlay = true;
    private string statusMessage = "Click Start Game to begin.";
    private bool GameOver = false;
    private string winnerMessage = string.Empty;
    private Card? LastHumanCard = null;
    private Card? LastCpuCard = null;
    private int? LastPlayedByIndex = null; // which player played the top pile card (0=human,1=cpu)
    // animation state for CPU play
    private bool IsAnimatingCpuCard = false;
    private bool AnimCpuToCenter = false;
    private string? AnimCpuCardUrl = null;
    // animation state for player play
    private bool IsAnimatingPlayerCard = false;
    private bool AnimPlayerToCenter = false;
    private string? AnimPlayerCardUrl = null;
        // take-pile animation state
        private bool IsAnimatingTakePile = false;
        private int? TakePileTargetIndex = null; // 0 or 1
        private Card[]? AnimPileCards = null;

    private int TotalCardsCount => (Players?.Sum(p => p.Deck?.Count ?? 0) ?? 0) + (Pile?.Count ?? 0);

    private bool IsHumanTurn => Players.Count > 0 && CurrentPlayerIndex == 0;

    private ElementReference playButton;

    private async Task StartGame()
    {
        ResetGame();
        DeckService.ResetDeck();
        var dealt = DeckService.DealToPlayers(2);
        Players = new List<Player>
        {
            new Player { Name = "Player 1", Deck = new Queue<Card>(dealt[0]) },
            new Player { Name = "Player 2 (CPU)", Deck = new Queue<Card>(dealt[1]) }
        };

        CurrentPlayerIndex = 0; // left of dealer
        statusMessage = "Player 1 to play.";
        GameOver = false;
    PenaltyActive = false;
    PenaltyPlayerIndex = null;
        StateHasChanged();

        // After UI has rendered, move focus to the Play Card button so Enter can be used
        try
        {
            // yield to allow render
            await Task.Yield();
            await JS.InvokeVoidAsync("focusElement", playButton);
        }
        catch
        {
            // best-effort, ignore JS errors
        }
    }

    private void ResetGame()
    {
        Players = new List<Player>();
        Pile = new Stack<Card>();
        CurrentPlayerIndex = 0;
        PenaltyCount = 0;
        LastCourtPlayer = null;
        statusMessage = "Click Start Game to begin.";
        GameOver = false;
        winnerMessage = string.Empty;
    LastHumanCard = null;
    LastCpuCard = null;
    }

    private async Task HumanPlay()
    {
        if (GameOver) return;
        if (!IsHumanTurn) return;
        if (Players.Count <= CurrentPlayerIndex) return;

        await PlayWithCooldown(Players[CurrentPlayerIndex]);
        await ContinueTurnsIfNeeded();
    }

    private async Task ContinueTurnsIfNeeded()
    {
        // After human play, let CPU act if it's their turn until human turn returns or game ends
        while (!IsHumanTurn && !GameOver)
        {
            await Task.Delay(350);
            // guard: ensure current player index is valid
            if (Players == null || Players.Count == 0) break;
            if (CurrentPlayerIndex < 0 || CurrentPlayerIndex >= Players.Count) break;
            var current = Players[CurrentPlayerIndex];
            if (current == null) break;
            await PlayWithCooldown(current);
        }
    }

    private async Task PlayWithCooldown(Player player)
    {
        if (!CanPlay) return;
        CanPlay = false;
        // capture player index now so we can decide whether to apply the CPU delay
        var playerIndex = Players?.IndexOf(player) ?? -1;
        try
        {
            await PlayOneCard(player);
        }
        finally
        {
            // enforce a 1 second cooldown before next play is allowed, but only for CPU players
            if (playerIndex != 0)
            {
                await Task.Delay(1000);
            }
            CanPlay = true;
            StateHasChanged();
        }
    }

    private async Task PlayOneCard(Player player)
    {
        await Task.Yield();
        if (GameOver) return;
        if (player is null)
        {
            // nothing to do
            return;
        }
        // determine player index
        var playerIndex = Players.IndexOf(player);
        if (player.Deck == null || player.Deck.Count == 0)
        {
            // player has no cards -> they lose
            EndGameOtherPlayer(player);
            return;
        }

        // Peek at the top card for animation/preview but don't remove it until after animation
        Card? card = null;
        try
        {
            card = player.Deck?.Peek();
        }
        catch
        {
            // fall back to enumerating first element
            card = player.Deck?.FirstOrDefault();
        }

        if (card is null)
        {
            // no card available — defensively advance
            if (Players != null && Players.Count > 0)
                CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
            return;
        }

        // If a player is playing, animate their card moving to center before revealing it in the pile
        if (playerIndex == 1 || playerIndex == 0)
        {
            try
            {
                if (playerIndex == 1)
                {
                    IsAnimatingCpuCard = true;
                    AnimCpuToCenter = false;
                    AnimCpuCardUrl = card.ImageUrl;
                }
                else
                {
                    IsAnimatingPlayerCard = true;
                    AnimPlayerToCenter = false;
                    AnimPlayerCardUrl = card.ImageUrl;
                }
                StateHasChanged();

                // allow the animated element to render
                await Task.Delay(50);

                // start animation to center
                if (playerIndex == 1)
                    AnimCpuToCenter = true;
                else
                    AnimPlayerToCenter = true;
                StateHasChanged();

                // wait for animation to complete (match CSS transition)
                await Task.Delay(650);
            }
            finally
            {
                // clear animation state after the visual transfer and keep last card for UI
                if (playerIndex == 1)
                {
                    IsAnimatingCpuCard = false;
                    AnimCpuToCenter = false;
                    LastCpuCard = card;
                }
                else
                {
                    IsAnimatingPlayerCard = false;
                    AnimPlayerToCenter = false;
                    LastHumanCard = card;
                }
                StateHasChanged();
            }
        }

        // dequeue the card (now that animation/preview is complete) and place it on the pile
        try
        {
            // remove the top card from the player's deck — this should be the same card we peeked
            if (player.Deck != null && player.Deck.Count > 0)
            {
                var dequeued = player.Deck.Dequeue();
                // push the dequeued card into the pile
                Pile.Push(dequeued);
                // record who played this card so the top-card rotation can reflect player side
                LastPlayedByIndex = playerIndex;
                // record last played for display
                if (playerIndex == 0) LastHumanCard = dequeued;
                else if (playerIndex == 1) LastCpuCard = dequeued;
                card = dequeued; // ensure subsequent logic refers to the dequeued card
            }
        }
        catch
        {
            // fallback: if dequeue failed, still push the peeked card
            Pile.Push(card);
        }
        var rank = card.Rank ?? "?";
        var suit = card.Suit ?? "?";
        statusMessage = $"{player.Name} played {rank} of {suit}.";
        if (IsCourt(card))
        {
            // court card played — set new penalty and make the next player the penalized player
            var rnk = card.Rank ?? string.Empty;
            PenaltyCount = CourtPenaltyForRank(rnk);
            LastCourtPlayer = player;
            // next player will be penalized
            var next = (playerIndex + 1) % Players.Count;
            PenaltyActive = true;
            PenaltyPlayerIndex = next;
            CurrentPlayerIndex = next;
            statusMessage = $"{player.Name} played {rnk}. Required cards: {PenaltyCount}";
            StateHasChanged();
            return;
        }

        // If a penalty is active, check whether this player is the penalized player
        if (PenaltyActive && PenaltyPlayerIndex.HasValue)
        {
            if (playerIndex == PenaltyPlayerIndex.Value)
            {
                // penalized player has played one of their required cards
                // if they played a court card above, penalty flow was handled already
                // here it's a non-court card: decrement penalty, and if still >0 they must play again
                PenaltyCount--;
                if (PenaltyCount > 0)
                {
                    // same player must play again
                    CurrentPlayerIndex = playerIndex;
                    statusMessage = $"Required cards remaining: {PenaltyCount}";
                    StateHasChanged();
                    return;
                }

                // Penalty exhausted without a court card — last court player takes the pile
                PenaltyActive = false;
                PenaltyPlayerIndex = null;
                if (LastCourtPlayer != null)
                {
                    // ensure the UI shows the last card that was played before we animate the pile transfer
                    StateHasChanged();
                    await Task.Delay(300);
                    await TakePileAsync(LastCourtPlayer);
                    var idx = Players.IndexOf(LastCourtPlayer);
                    if (idx >= 0) CurrentPlayerIndex = idx;
                    statusMessage = $"{(LastCourtPlayer?.Name ?? "Player")} wins the pile.";
                    StateHasChanged();
                    return;
                }
            }
            else
            {
                // not the penalized player's turn — normal advance
                CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
                StateHasChanged();
                return;
            }
        }

    // Normal play and no penalty active -> advance to next player
    CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
        CheckForWin();
        StateHasChanged();
    }

    private void TakePile(Player taker)
    {
        // synchronous transfer used as a fallback
        if (taker == null) return;
        if (taker.Deck == null) taker.Deck = new System.Collections.Generic.Queue<Card>();
        // take all cards from pile (bottom first)
        var cards = Pile.ToArray();
        Array.Reverse(cards); // now bottom -> top
        foreach (var c in cards)
            taker.Deck.Enqueue(c);

        Pile.Clear();
        PenaltyCount = 0;
        LastCourtPlayer = null;
    }

    private async Task TakePileAsync(Player taker)
    {
        if (taker == null) return;
        // prepare animation state: snapshot pile
        var cards = Pile.ToArray();
        AnimPileCards = cards;
        TakePileTargetIndex = Players.IndexOf(taker);
        IsAnimatingTakePile = true;
        StateHasChanged();

        // give the animated element a moment to render, then move it to the player's side
        await Task.Delay(50);
        // choose direction based on target index (0 = left, 1 = right)
        var toLeft = TakePileTargetIndex == 0;
        // set a short flag on the UI via CSS class by keeping TakePileTargetIndex and IsAnimatingTakePile
        StateHasChanged();

        // animate
        await Task.Delay(750);

        // after animation completes, transfer cards into taker's deck
        if (taker.Deck == null) taker.Deck = new System.Collections.Generic.Queue<Card>();
        Array.Reverse(cards); // bottom -> top
        foreach (var c in cards)
            taker.Deck.Enqueue(c);

        // clear pile and reset animation state
        Pile.Clear();
        PenaltyCount = 0;
        LastCourtPlayer = null;
        IsAnimatingTakePile = false;
        TakePileTargetIndex = null;
        AnimPileCards = null;
        StateHasChanged();
    }

    private void EndGameOtherPlayer(Player emptyPlayer)
    {
    // Show the player who ran out of cards as the loser so the UI is explicit
    GameOver = true;
    winnerMessage = $"{emptyPlayer.Name} has lost the game.";
    statusMessage = winnerMessage;
    }

    private void CheckForWin()
    {
        var nonEmpty = Players.Count(p => p.Deck.Count > 0);
        if (nonEmpty == 1)
        {
            var winner = Players.First(p => p.Deck.Count > 0);
            GameOver = true;
            winnerMessage = $"{winner.Name} has won the game!";
            statusMessage = winnerMessage;
        }
    }

    private static bool IsCourt(Card card) => card.Rank is "J" or "Q" or "K" or "A";

    private static int CourtPenaltyForRank(string rank) => rank switch
    {
        "J" => 1,
        "Q" => 2,
        "K" => 3,
        "A" => 4,
        _ => 0
    };

    private string PenaltyBadgeClass(int count)
    {
        return count switch
        {
            1 => "penalty-1",
            2 => "penalty-2",
            3 => "penalty-3",
            4 => "penalty-4",
            _ => "bg-secondary"
        };
    }

    private Card? GetNextCardForPlayer(int playerIndex)
    {
        if (Players == null || playerIndex < 0 || playerIndex >= Players.Count) return null;
        var deck = Players[playerIndex].Deck;
        if (deck == null || deck.Count == 0) return null;
        // Queue<T> doesn't expose Peek in older frameworks? but in .NET it does
        try
        {
            return deck.Peek();
        }
        catch
        {
            // fallback: enumerate first
            return deck.FirstOrDefault();
        }
    }

    private ElementReference startButton;
    private bool prevPlayEnabled = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Move keyboard focus to the Start Game button so pressing Enter starts the game
            try
            {
                await JS.InvokeVoidAsync("focusElement", startButton);
            }
            catch
            {
                // ignore JS errors — focusing is best-effort
            }
        }

        // Determine whether Play Card is enabled now
        var playEnabled = IsHumanTurn && !GameOver && CanPlay;
        if (playEnabled && !prevPlayEnabled)
        {
            // play button has just become available — move focus so Enter will trigger it
            try
            {
                await JS.InvokeVoidAsync("focusElement", playButton);
            }
            catch
            {
                // ignore JS errors
            }
        }
        prevPlayEnabled = playEnabled;
    }
}
