@page "/stripjacknaked"
@using System.Linq
@using System.Threading.Tasks
@using CardGame.Models
@using CardGame.Services
@inject DeckService DeckService
@inject IJSRuntime JS

<h3>Strip Jack Naked</h3>

<div class="mb-3">
    <button class="btn btn-primary me-2" @onclick="StartGame" @ref="startButton">Start Game</button>
    <button class="btn btn-secondary me-2" @onclick="ResetGame">Reset Game</button>
    <button class="btn btn-success" @onclick="HumanPlay" disabled="@(!IsHumanTurn || GameOver || !CanPlay)" @ref="playButton">Play Card</button>
    @statusMessage
</div>

<div class="row">

    <div class="col-md-4" style="@(CurrentPlayerIndex==0 ? "background:#f8f9fa;border-radius:6px;" : "")">
        @if (Players.Count > 0)
        {
            var isPenalized0 = PenaltyActive && PenaltyPlayerIndex.HasValue && PenaltyPlayerIndex.Value == 0;
            <h5>
                @Players[0].Name
                @(CurrentPlayerIndex==0 ? " ⬅️ Your turn" : "")
                @if (isPenalized0)
                {
                    <span class="badge bg-danger ms-2" style="font-size:1.15rem; padding:0.45rem 0.6rem;">@PenaltyCount</span>
                }
            </h5>
        }
        else
        {
            <h5>Player 1 (empty)</h5>
        }
    <!-- deck graphic removed for player 1 per UI update; keep spacer for layout -->
    <div style="width:100%; height:170px;"></div>
        @* last human card (reduced size for symmetry with CPU) *@
        <div style="margin-top:6px;">
            @if (LastHumanCard != null)
            {
                <img src="@LastHumanCard.ImageUrl" alt="@LastHumanCard.Rank of @LastHumanCard.Suit" style="width:90px; box-shadow:0 4px 6px rgba(0,0,0,0.15);" />
            }
            else
            {
                <img src="/cards/Cards-Blank.svg" alt="no-card" style="width:90px;" />
            }
        </div>

        @* progress meter showing player's share of the total cards (players' decks + pile) *@
        @if (Players.Count > 0)
        {
            var total = TotalCardsCount;
            var pct = total == 0 ? 0 : (int)Math.Round(100.0 * (Players[0].Deck?.Count ?? 0) / total);
            <div class="mt-2" style="width:100%;">
                <div class="progress" style="height:12px; background:#e9ecef; border-radius:6px;">
                    <div class="progress-bar" role="progressbar" style="width:@pct%; background:#0d6efd;" aria-valuenow="@pct" aria-valuemin="0" aria-valuemax="100">
                        <span class="visually-hidden">@pct% of cards</span>
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="col-md-4 text-center">
        <h5>Center Pile (@Pile.Count)</h5>
        <div style="position:relative; height:200px;">
        @if (Pile.Count > 0)
        {
            var arr = Pile.ToArray();
            // top card is arr[0] since Stack.ToArray returns LIFO; show only top
            var top = arr.Length > 0 ? arr[0] : null;
            if (top != null)
            {
                <img src="@top.ImageUrl" alt="@top.Rank of @top.Suit" style="width:160px; position:absolute; left:50%; transform:translateX(-50%) rotate(4deg); top:40px; box-shadow:0 6px 12px rgba(0,0,0,0.25); opacity:1;" />
            }
        }
        else
        {
            <img src="/cards/Cards-Blank.svg" alt="empty" style="width:160px;" />
        }
        </div>
    </div>

    <div class="col-md-4 text-end" style="@(CurrentPlayerIndex==1 ? "background:#f8f9fa;border-radius:6px;" : "")">
        @if (Players.Count > 1)
        {
            var isPenalized1 = PenaltyActive && PenaltyPlayerIndex.HasValue && PenaltyPlayerIndex.Value == 1;
            <h5>
                @Players[1].Name
                @(CurrentPlayerIndex==1 ? " ⬅️ Their turn" : "")
                @if (isPenalized1)
                {
                    <span class="badge bg-danger ms-2" style="font-size:1.15rem; padding:0.45rem 0.6rem;">@PenaltyCount</span>
                }
            </h5>
        }
        else
        {
            <h5>Player 2 (CPU)</h5>
        }
        <div>
            <img src="/cards/Cards-Blank.svg" alt="face-down" style="width:120px; opacity:1;" />
        </div>
        @* last CPU card (reduced size for symmetry) *@
        <div style="margin-top:6px;">
            @if (LastCpuCard != null)
            {
                <img src="@LastCpuCard.ImageUrl" alt="@LastCpuCard.Rank of @LastCpuCard.Suit" style="width:90px; box-shadow:0 4px 6px rgba(0,0,0,0.15);" />
            }
            else
            {
                <img src="/cards/Cards-Blank.svg" alt="no-card" style="width:90px;" />
            }
        </div>

        @* progress meter for player 2 (CPU) *@
        @if (Players.Count > 1)
        {
            var total = TotalCardsCount;
            var pct2 = total == 0 ? 0 : (int)Math.Round(100.0 * (Players[1].Deck?.Count ?? 0) / total);
            <div class="mt-2" style="width:100%;">
                <div class="progress" style="height:12px; background:#e9ecef; border-radius:6px;">
                    <div class="progress-bar" role="progressbar" style="width:@pct2%; background:#198754;" aria-valuenow="@pct2" aria-valuemin="0" aria-valuemax="100">
                        <span class="visually-hidden">@pct2% of cards</span>
                    </div>
                </div>
            </div>
        }
    </div>
</div>

@if (GameOver)
{
    <div class="alert alert-success mt-3">@winnerMessage</div>
}

@code {
    // ...existing code...
    private List<Player> Players = new();
    private Stack<Card> Pile = new();
    private int CurrentPlayerIndex = 0; // 0 = human, 1 = CPU
    private int PenaltyCount = 0;
    private bool PenaltyActive = false;
    private int? PenaltyPlayerIndex = null; // which player must play penalty cards
    private Player? LastCourtPlayer = null;
    private bool CanPlay = true;
    private string statusMessage = "Click Start Game to begin.";
    private bool GameOver = false;
    private string winnerMessage = string.Empty;
    private Card? LastHumanCard = null;
    private Card? LastCpuCard = null;

    private int TotalCardsCount => (Players?.Sum(p => p.Deck?.Count ?? 0) ?? 0) + (Pile?.Count ?? 0);

    private bool IsHumanTurn => Players.Count > 0 && CurrentPlayerIndex == 0;

    private ElementReference playButton;

    private async Task StartGame()
    {
        ResetGame();
        DeckService.ResetDeck();
        var dealt = DeckService.DealToPlayers(2);
        Players = new List<Player>
        {
            new Player { Name = "Player 1", Deck = new Queue<Card>(dealt[0]) },
            new Player { Name = "Player 2 (CPU)", Deck = new Queue<Card>(dealt[1]) }
        };

        CurrentPlayerIndex = 0; // left of dealer
        statusMessage = "Player 1 to play.";
        GameOver = false;
    PenaltyActive = false;
    PenaltyPlayerIndex = null;
        StateHasChanged();

        // After UI has rendered, move focus to the Play Card button so Enter can be used
        try
        {
            // yield to allow render
            await Task.Yield();
            await JS.InvokeVoidAsync("focusElement", playButton);
        }
        catch
        {
            // best-effort, ignore JS errors
        }
    }

    private void ResetGame()
    {
        Players = new List<Player>();
        Pile = new Stack<Card>();
        CurrentPlayerIndex = 0;
        PenaltyCount = 0;
        LastCourtPlayer = null;
        statusMessage = "Click Start Game to begin.";
        GameOver = false;
        winnerMessage = string.Empty;
    LastHumanCard = null;
    LastCpuCard = null;
    }

    private async Task HumanPlay()
    {
        if (GameOver) return;
        if (!IsHumanTurn) return;
        if (Players.Count <= CurrentPlayerIndex) return;

        await PlayWithCooldown(Players[CurrentPlayerIndex]);
        await ContinueTurnsIfNeeded();
    }

    private async Task ContinueTurnsIfNeeded()
    {
        // After human play, let CPU act if it's their turn until human turn returns or game ends
        while (!IsHumanTurn && !GameOver)
        {
            await Task.Delay(350);
            // guard: ensure current player index is valid
            if (Players == null || Players.Count == 0) break;
            if (CurrentPlayerIndex < 0 || CurrentPlayerIndex >= Players.Count) break;
            var current = Players[CurrentPlayerIndex];
            if (current == null) break;
            await PlayWithCooldown(current);
        }
    }

    private async Task PlayWithCooldown(Player player)
    {
        if (!CanPlay) return;
        CanPlay = false;
        // capture player index now so we can decide whether to apply the CPU delay
        var playerIndex = Players?.IndexOf(player) ?? -1;
        try
        {
            await PlayOneCard(player);
        }
        finally
        {
            // enforce a 1 second cooldown before next play is allowed, but only for CPU players
            if (playerIndex != 0)
            {
                await Task.Delay(1000);
            }
            CanPlay = true;
            StateHasChanged();
        }
    }

    private async Task PlayOneCard(Player player)
    {
        await Task.Yield();
        if (GameOver) return;
        if (player is null)
        {
            // nothing to do
            return;
        }
        // determine player index
        var playerIndex = Players.IndexOf(player);
        if (player.Deck == null || player.Deck.Count == 0)
        {
            // player has no cards -> they lose
            EndGameOtherPlayer(player);
            return;
        }

        var card = player.Deck.Dequeue();
        if (card is null)
        {
            // defensively advance to next player
            if (Players != null && Players.Count > 0)
                CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
            return;
        }

        // record last human card for display
        // record last human/cpu card for display
        if (playerIndex == 0)
        {
            LastHumanCard = card;
        }
        else if (playerIndex == 1)
        {
            LastCpuCard = card;
        }

        Pile.Push(card);
        var rank = card.Rank ?? "?";
        var suit = card.Suit ?? "?";
        statusMessage = $"{player.Name} played {rank} of {suit}.";
        if (IsCourt(card))
        {
            // court card played — set new penalty and make the next player the penalized player
            var rnk = card.Rank ?? string.Empty;
            PenaltyCount = CourtPenaltyForRank(rnk);
            LastCourtPlayer = player;
            // next player will be penalized
            var next = (playerIndex + 1) % Players.Count;
            PenaltyActive = true;
            PenaltyPlayerIndex = next;
            CurrentPlayerIndex = next;
            statusMessage = $"{player.Name} played {rnk}. Required cards: {PenaltyCount}";
            StateHasChanged();
            return;
        }

        // If a penalty is active, check whether this player is the penalized player
        if (PenaltyActive && PenaltyPlayerIndex.HasValue)
        {
            if (playerIndex == PenaltyPlayerIndex.Value)
            {
                // penalized player has played one of their required cards
                // if they played a court card above, penalty flow was handled already
                // here it's a non-court card: decrement penalty, and if still >0 they must play again
                PenaltyCount--;
                if (PenaltyCount > 0)
                {
                    // same player must play again
                    CurrentPlayerIndex = playerIndex;
                    statusMessage = $"Required cards remaining: {PenaltyCount}";
                    StateHasChanged();
                    return;
                }

                // Penalty exhausted without a court card — last court player takes the pile
                PenaltyActive = false;
                PenaltyPlayerIndex = null;
                if (LastCourtPlayer != null)
                {
                    // ensure the UI shows the last card that was played before we remove/transfer the pile
                    StateHasChanged();
                    await Task.Delay(1000);
                    TakePile(LastCourtPlayer);
                    var idx = Players.IndexOf(LastCourtPlayer);
                    if (idx >= 0) CurrentPlayerIndex = idx;
                    statusMessage = $"{(LastCourtPlayer?.Name ?? "Player")} wins the pile and will play next.";
                    StateHasChanged();
                    return;
                }
            }
            else
            {
                // not the penalized player's turn — normal advance
                CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
                StateHasChanged();
                return;
            }
        }

    // Normal play and no penalty active -> advance to next player
    CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
        CheckForWin();
        StateHasChanged();
    }

    private void TakePile(Player taker)
    {
        if (taker == null) return;
        if (taker.Deck == null) taker.Deck = new System.Collections.Generic.Queue<Card>();
        // take all cards from pile (bottom first)
        var cards = Pile.ToArray();
        Array.Reverse(cards); // now bottom -> top
        foreach (var c in cards)
            taker.Deck.Enqueue(c);

        Pile.Clear();
        PenaltyCount = 0;
        LastCourtPlayer = null;
    }

    private void EndGameOtherPlayer(Player emptyPlayer)
    {
    // Show the player who ran out of cards as the loser so the UI is explicit
    GameOver = true;
    winnerMessage = $"{emptyPlayer.Name} has lost the game.";
    statusMessage = winnerMessage;
    }

    private void CheckForWin()
    {
        var nonEmpty = Players.Count(p => p.Deck.Count > 0);
        if (nonEmpty == 1)
        {
            var winner = Players.First(p => p.Deck.Count > 0);
            GameOver = true;
            winnerMessage = $"{winner.Name} has won the game!";
            statusMessage = winnerMessage;
        }
    }

    private static bool IsCourt(Card card) => card.Rank is "J" or "Q" or "K" or "A";

    private static int CourtPenaltyForRank(string rank) => rank switch
    {
        "J" => 1,
        "Q" => 2,
        "K" => 3,
        "A" => 4,
        _ => 0
    };

    private ElementReference startButton;
    private bool prevPlayEnabled = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Move keyboard focus to the Start Game button so pressing Enter starts the game
            try
            {
                await JS.InvokeVoidAsync("focusElement", startButton);
            }
            catch
            {
                // ignore JS errors — focusing is best-effort
            }
        }

        // Determine whether Play Card is enabled now
        var playEnabled = IsHumanTurn && !GameOver && CanPlay;
        if (playEnabled && !prevPlayEnabled)
        {
            // play button has just become available — move focus so Enter will trigger it
            try
            {
                await JS.InvokeVoidAsync("focusElement", playButton);
            }
            catch
            {
                // ignore JS errors
            }
        }
        prevPlayEnabled = playEnabled;
    }
}
