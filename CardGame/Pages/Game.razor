@page "/stripjacknaked"
@using System.Linq
@using System.Threading.Tasks
@using CardGame.Models
@using CardGame.Services
@using CardGame.Shared
@inject DeckService DeckService
@inject IJSRuntime JS

<div class="western-header">
    <h1 class="western-title">🤠 STRIP JACK NAKED 🤠</h1>
    <div class="western-subtitle">~ A Wild West Card Showdown ~</div>
</div>

<style>
    /* Western Theme Styles */
    body {
        background: linear-gradient(45deg, #8B4513 0%, #CD853F 50%, #DEB887 100%);
        background-attachment: fixed;
        min-height: 100vh;
        font-family: 'Segoe UI', 'Arial', sans-serif;
    }
    
    .western-header {
        text-align: center;
        margin-bottom: 2rem;
        padding: 1.5rem;
        background: linear-gradient(135deg, #8B4513 0%, #A0522D  50%, #CD853F 100%);
        border: 4px solid #654321;
        border-radius: 15px;
        box-shadow: 
            0 0 20px rgba(139, 69, 19, 0.7),
            inset 0 0 20px rgba(255, 255, 255, 0.1);
        position: relative;
    }
    
    .western-header::before {
        content: "";
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, #DAA520, #B8860B, #FFD700, #B8860B);
        border-radius: 17px;
        z-index: -1;
    }
    
    .western-title {
        font-family: 'Segoe UI', 'Arial', sans-serif;
        font-size: 2.5rem;
        color: #FFFF99;
        text-shadow: 
            2px 2px 0px #654321,
            4px 4px 8px rgba(0,0,0,0.8);
        margin: 0;
        letter-spacing: 2px;
        font-weight: bold;
    }
    
    .western-subtitle {
        font-family: 'Segoe UI', 'Arial', sans-serif;
        font-size: 1.1rem;
        color: #FFFFFF;
        margin-top: 0.5rem;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        font-style: italic;
        font-weight: 500;
    }

    /* Western Button Styles */
    .btn {
        font-family: 'Segoe UI', 'Arial', sans-serif;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
        border: 3px solid #654321;
        border-radius: 8px;
        padding: 12px 24px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        transition: all 0.3s ease;
        font-size: 0.9rem;
    }
    
    .btn-primary {
        background: linear-gradient(135deg, #B8860B 0%, #DAA520 50%, #FFD700 100%);
        color: #000000;
        border-color: #8B4513;
        text-shadow: none;
    }
    
    .btn-primary:hover {
        background: linear-gradient(135deg, #DAA520 0%, #FFD700 50%, #FFFF99 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        color: #000000;
    }
    
    .btn-secondary {
        background: linear-gradient(135deg, #A0522D 0%, #CD853F 50%, #DEB887 100%);
        color: #000000;
        border-color: #654321;
        text-shadow: none;
    }
    
    .btn-success {
        background: linear-gradient(135deg, #228B22 0%, #32CD32 50%, #90EE90 100%);
        color: #000000;
        border-color: #006400;
        text-shadow: none;
    }

    /* Western Game Area Styles */
    .western-player-area {
        background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
        border: 3px solid #654321;
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 
            0 0 15px rgba(139, 69, 19, 0.6),
            inset 0 0 15px rgba(255, 255, 255, 0.1);
        position: relative;
        height: fit-content;
    }
    
    .western-player-area::before {
        content: "";
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        bottom: 8px;
        border: 1px solid #DAA520;
        border-radius: 8px;
        pointer-events: none;
    }
    
    .western-player-area.active {
        background: linear-gradient(135deg, #B8860B 0%, #DAA520 100%);
        box-shadow: 
            0 0 25px rgba(218, 165, 32, 0.8),
            inset 0 0 20px rgba(255, 255, 255, 0.2);
    }
    
    .western-center-area {
        background: radial-gradient(circle, #654321 0%, #8B4513 50%, #A0522D 100%);
        border: 4px solid #DAA520;
        border-radius: 20px;
        padding: 1.5rem;
        box-shadow: 
            0 0 30px rgba(218, 165, 32, 0.7),
            inset 0 0 25px rgba(0, 0, 0, 0.3);
        position: relative;
        height: fit-content;
    }
    
    .western-center-area::before {
        content: "★";
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2rem;
        color: #FFD700;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    }

    /* Western Typography */
    h5 {
        font-family: 'Segoe UI', 'Arial', sans-serif;
        color: #FFFFFF;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        font-size: 1.3rem;
        margin-bottom: 1rem;
        font-weight: 600;
    }
    
    .status-message {
        font-family: 'Segoe UI', 'Arial', sans-serif;
        color: #FFFFFF;
        background: rgba(101, 67, 33, 0.95);
        padding: 10px 18px;
        border-radius: 8px;
        border: 2px solid #654321;
        display: inline-block;
        margin-left: 1rem;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        font-weight: 500;
        font-size: 0.95rem;
    }

    /* Western Progress Bars */
    .western-progress {
        background: linear-gradient(90deg, #654321 0%, #8B4513 100%);
        border: 2px solid #DAA520;
        border-radius: 10px;
        height: 20px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .western-progress-bar {
        background: linear-gradient(90deg, #DAA520 0%, #FFD700 50%, #FFFF99 100%);
        border-radius: 8px;
        height: 100%;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        transition: width 0.5s ease;
    }
    
    .western-progress-bar.cpu {
        background: linear-gradient(90deg, #DC143C 0%, #FF6347 50%, #FF7F7F 100%);
        box-shadow: 0 0 10px rgba(220, 20, 60, 0.6);
    }

    /* Western Badge Styles */
    .western-badge {
        font-family: 'Segoe UI', 'Arial', sans-serif;
        border: 2px solid #654321;
        border-radius: 50%;
        padding: 8px 12px;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
        font-weight: 600;
        font-size: 0.9rem;
    }
    
    /* Penalty color classes: 1..4 */
    .penalty-1 { 
        background: linear-gradient(135deg, #DC143C 0%, #FF6347 100%);
        color: #fff;
        border-color: #8B0000;
    }
    .penalty-2 { 
        background: linear-gradient(135deg, #FF8C00 0%, #FFA500 100%);
        color: #fff;
        border-color: #FF4500;
    }
    .penalty-3 { 
        background: linear-gradient(135deg, #FFD700 0%, #FFFF99 100%);
        color: #654321;
        border-color: #DAA520;
    }
    .penalty-4 { 
        background: linear-gradient(135deg, #228B22 0%, #32CD32 100%);
        color: #fff;
        border-color: #006400;
    }

    /* Western Card Animations */
    .animated-card {
        position: absolute;
        top: 40px;
        height: 120px;
        left: 50%;
        transition: transform 600ms ease, height 600ms ease, opacity 300ms ease;
        z-index: 60;
        /* start centered but translated so children can shift off-screen via translateX */
        transform: translateX(-50%) rotate(0deg);
        box-shadow: 0 8px 16px rgba(139, 69, 19, 0.4);
        border: 2px solid #DAA520;
        border-radius: 8px;
        background-color: #FFFEF7;
        padding: 4px;
        opacity: 0; /* start hidden; become visible via .visible */
    }

    /* When moving to center, normalize to translateX(-50%) and apply a rotation */
    .animated-card.to-center {
        transform: translateX(-50%) rotate(-20deg);
        height: 160px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    }

    /* CPU starts to the right of center and moves to center when .to-center added */
    .animated-card.player { transform: translateX(350%) rotate(0deg); }
    .animated-card.player.to-center {
        transform: translateX(-50%) rotate(20deg);
        height: 160px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    }

    /* Human (player 0) starts to the left of center and moves to center when .to-center added */
    .animated-card.human { transform: translateX(-350%) rotate(0deg); }
    .animated-card.human.to-center {
        transform: translateX(-50%) rotate(-20deg);
        height: 160px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    }
    
    /* All card images get consistent styling */
    img[src*="/cards/"] {
        background-color: #FFFEF7;
        border: 1px solid #E8E8E8;
        border-radius: 6px;
        padding: 3px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    
    /* Pile-to-hand animation with western flair */
    .pile-anim {
        position: absolute;
        left: 50%;
        top: 40px;
        transform: translateX(-50%) rotate(4deg) scale(1);
        height: 160px;
        transition: transform 700ms cubic-bezier(.2,.9,.2,1), opacity 300ms ease;
        z-index: 80;
        border: 2px solid #DAA520;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        background-color: #FFFEF7;
        padding: 4px;
    }

    /* Fade-controlled preview for the player's top card so it can smoothly disappear
       just before the animated overlay runs. Keeps layout because opacity only is changed. */
    .top-preview {
        height: 160px;
        transition: opacity 220ms ease;
    }
    .top-preview.fading {
        opacity: 0;
    }

    /* Make animated-card fade in/out smoothly when toggled */
    .animated-card.visible {
        opacity: 1;
    }
    
    .pile-anim.to-left { 
        transform: translateX(-250%) rotate(-8deg) scale(0.9);
        box-shadow: 0 0 15px rgba(218, 165, 32, 0.8);
    }
    
    .pile-anim.to-right { 
        transform: translateX(150%) rotate(8deg) scale(0.9);
        box-shadow: 0 0 15px rgba(218, 165, 32, 0.8);
    }
    
    /* Western Alert Styles */
    .alert-success {
        background: linear-gradient(135deg, #228B22 0%, #32CD32 100%);
        border: 3px solid #006400;
        color: #FFFFFF;
        font-family: 'Segoe UI', 'Arial', sans-serif;
        font-size: 1.1rem;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        border-radius: 12px;
        box-shadow: 0 0 15px rgba(34, 139, 34, 0.6);
        font-weight: 600;
    }

    /* Force single line layout */
    .game-layout {
        display: flex;
        flex-wrap: nowrap;
        align-items: flex-start;
        gap: 1rem;
        min-height: 300px;
    }
    
    .player-column {
        flex: 1;
        min-width: 0; /* Allow flex items to shrink below content size */
        max-width: 33.333%;
    }
    
    .center-column {
        flex: 1;
        min-width: 0;
        max-width: 33.333%;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    /* Responsive adjustments for very small screens */
    @@media (max-width: 768px) {
        .game-layout {
            gap: 0.5rem;
        }
        
        .western-title {
            font-size: 2rem;
        }
        
        .western-subtitle {
            font-size: 1rem;
        }
        
        h5 {
            font-size: 1.1rem;
        }
        
        .status-message {
            font-size: 0.85rem;
            padding: 8px 12px;
        }
    }
</style>

<div class="mb-3">
    <button class="btn btn-primary me-2" @onclick="StartGame" @ref="startButton">🎲 Start New Game</button>
    <button class="btn btn-success" @onclick="HumanPlay" disabled="@(!IsHumanTurn || GameOver || !CanPlay)" @ref="playButton">🂡 Play Card</button>
    <button class="btn btn-secondary ms-2" @onclick="() => rulesVisible = true">📜 Rules</button>
    <span class="status-message">@statusMessage</span>
</div>

<div class="game-layout">

    <div class="player-column western-player-area @(CurrentPlayerIndex==0 ? "active" : "")">
        @if (Players.Count > 0)
        {
            var isPenalized0 = PenaltyActive && PenaltyPlayerIndex.HasValue && PenaltyPlayerIndex.Value == 0;
            <h5>
                🤠 @Players[0].Name
                @(CurrentPlayerIndex==0 ? " ⬅️ Your Draw!" : "")
                @if (isPenalized0)
                {
                    <span class="badge western-badge ms-2 @PenaltyBadgeClass(PenaltyCount)" style="font-size:1.15rem; padding:0.45rem 0.6rem;">@PenaltyCount</span>
                }
            </h5>
        }
        else
        {
            <h5>🤠 Player 1 (empty)</h5>
        }
    <!-- deck graphic removed for player 1 per UI update; keep spacer for layout -->
    
        @* next human card (top of their deck) *@
        <div style="margin-top:6px;">
                @{
                    var next = GetNextCardForPlayer(0);
                    if (next != null)
                    {
                        // If the player's card is currently being animated for this same card,
                        // start fading the preview slightly earlier so the animation appears seamless.
                        var fadePreview = IsAnimatingPlayerCard && !string.IsNullOrEmpty(AnimPlayerCardUrl) && AnimPlayerCardUrl == next.ImageUrl;
                        var previewClass = "top-preview" + (fadePreview ? " fading" : "");
                        /* Show the human's top card face-up (right-aligned) so they can see it before playing */
                        <div style="display:flex; justify-content:flex-end;">
                            <img src="@next.ImageUrl" class="@previewClass" alt="@next.Rank of @next.Suit" style="box-shadow:0 4px 6px rgba(0,0,0,0.15);" />
                        </div>
                    }
                    else
                    {
                        <div style="display:flex; justify-content:flex-end;">
                            <img src="/cards/Cards-Blank.svg" alt="no-card" style="height:160px;" />
                        </div>
                    }
                }
        </div>

        @* progress meter showing player's share of the total cards (players' decks + pile) *@
        @if (Players.Count > 0)
        {
            var total = TotalCardsCount;
            var pct = total == 0 ? 0 : (int)Math.Round(100.0 * (Players[0].Deck?.Count ?? 0) / total);
            <div class="mt-2" style="width:100%;">
                <div class="western-progress">
                    <div class="western-progress-bar" role="progressbar" style="width:@pct%;" aria-valuenow="@pct" aria-valuemin="0" aria-valuemax="100">
                        <span class="visually-hidden">@pct% of cards</span>
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="center-column western-center-area">
        <h5>🃏 Center Pile (@Pile.Count) 🃏</h5>
        <div style="position:relative; height:200px;">
        @if (Pile.Count > 0)
        {
            var arr = Pile.ToArray();
            // top card is arr[0] since Stack.ToArray returns LIFO; show only top
            var top = arr.Length > 0 ? arr[0] : null;
            if (top != null)
            {
                var rotateDeg = (LastPlayedByIndex == 0) ? -20 : 20;
                <img src="@top.ImageUrl" alt="@top.Rank of @top.Suit" style="@($"height:160px; position:absolute; left:50%; transform:translateX(-50%) rotate({rotateDeg}deg); top:40px; box-shadow:0 6px 12px rgba(0,0,0,0.25); opacity:1;")" />
            }
        }
        else
        {
            // Don't show the blank card image when the pile is empty — render
            // an empty spacer to preserve layout but avoid the white card graphic.
            <div style="height:160px;"></div>
        }
        @* Animated CPU card overlays *@
        @if (IsAnimatingCpuCard && !string.IsNullOrEmpty(AnimCpuCardUrl))
        {
            var cpuClass = "animated-card player " + (AnimCpuToCenter ? "to-center" : "") + " visible";
            <img src="@AnimCpuCardUrl" class="@cpuClass" />
        }
        @if (IsAnimatingPlayerCard && !string.IsNullOrEmpty(AnimPlayerCardUrl))
        {
            // Use 'human' class so player's animation starts from the left side
            var playerAnimClass = "animated-card human " + (AnimPlayerToCenter ? "to-center" : "") + " visible";
            <img src="@AnimPlayerCardUrl" class="@playerAnimClass" />
        }
        @if (IsAnimatingTakePile && AnimPileCards != null && AnimPileCards.Length > 0)
        {
            var top = AnimPileCards.Length > 0 ? AnimPileCards[0] : null;
            if (top != null)
            {
                var cls = "pile-anim" + (TakePileTargetIndex == 0 ? " to-left" : (TakePileTargetIndex == 1 ? " to-right" : ""));
                <img src="@top.ImageUrl" class="@cls" style="opacity:1;" />
            }
        }
        </div>
    </div>

    <div class="player-column western-player-area @(CurrentPlayerIndex==1 ? "active" : "")" style="text-align: right;">
        @if (Players.Count > 1)
        {
            var isPenalized1 = PenaltyActive && PenaltyPlayerIndex.HasValue && PenaltyPlayerIndex.Value == 1;
            <h5>
                🤖 @Players[1].Name
                @(CurrentPlayerIndex==1 ? " ⬅️ Their Draw!" : "")
                @if (isPenalized1)
                {
                    <span class="badge western-badge ms-2 @PenaltyBadgeClass(PenaltyCount)" style="font-size:1.15rem; padding:0.45rem 0.6rem;">@PenaltyCount</span>
                }
            </h5>
        }
        else
        {
            <h5>🤖 Player 2 (CPU)</h5>
        }
        @* single CPU card (back) shown left-aligned; no duplicate deck preview *@
        <div style="margin-top:6px; display:flex; justify-content:flex-start;">
            @{ 
                var nextCpu = GetNextCardForPlayer(1);
                if (nextCpu != null)
                {
                    <img src="/cards/Cards-Reverse.svg" alt="face-down" style="height:160px; box-shadow:0 4px 6px rgba(0,0,0,0.15);" />
                }
                else
                {
                    <img src="/cards/Cards-Blank.svg" alt="no-card" style="height:160px;" />
                }
            }
        </div>

        @* progress meter for player 2 (CPU) *@
        @if (Players.Count > 1)
        {
            var total = TotalCardsCount;
            var pct2 = total == 0 ? 0 : (int)Math.Round(100.0 * (Players[1].Deck?.Count ?? 0) / total);
            <div class="mt-2" style="width:100%;">
                <div class="western-progress">
                    <div class="western-progress-bar cpu" role="progressbar" style="width:@pct2%;" aria-valuenow="@pct2" aria-valuemin="0" aria-valuemax="100">
                        <span class="visually-hidden">@pct2% of cards</span>
                    </div>
                </div>
            </div>
        }
    </div>
</div>

@if (GameOver)
{
    <div class="alert alert-success mt-3">@winnerMessage</div>
}

@* Rules modal component instance (bind visibility) *@
<RulesModal @bind-Visible="rulesVisible" />

@code {
    // controls visibility of the rules modal
    private bool rulesVisible = false;

    // ...existing code...
    private List<Player> Players = new();
    private Stack<Card> Pile = new();
    private int CurrentPlayerIndex = 0; // 0 = human, 1 = CPU
    private int PenaltyCount = 0;
    private bool PenaltyActive = false;
    private int? PenaltyPlayerIndex = null; // which player must play penalty cards
    private Player? LastCourtPlayer = null;
    private bool CanPlay = true;
    private string statusMessage = "Click Start Game to begin.";
    private bool GameOver = false;
    private string winnerMessage = string.Empty;
    private Card? LastHumanCard = null;
    private Card? LastCpuCard = null;
    private int? LastPlayedByIndex = null; // which player played the top pile card (0=human,1=cpu)
    // animation state for CPU play
    private bool IsAnimatingCpuCard = false;
    private bool AnimCpuToCenter = false;
    private string? AnimCpuCardUrl = null;
    // animation state for player play
    private bool IsAnimatingPlayerCard = false;
    private bool AnimPlayerToCenter = false;
    private string? AnimPlayerCardUrl = null;
        // take-pile animation state
        private bool IsAnimatingTakePile = false;
        private int? TakePileTargetIndex = null; // 0 or 1
        private Card[]? AnimPileCards = null;

    private int TotalCardsCount => (Players?.Sum(p => p.Deck?.Count ?? 0) ?? 0) + (Pile?.Count ?? 0);

    private bool IsHumanTurn => Players.Count > 0 && CurrentPlayerIndex == 0;

    private ElementReference playButton;

    private async Task StartGame()
    {
        // perform reset logic inline (previously in ResetGame)
        Players = new List<Player>();
        Pile = new Stack<Card>();
        CurrentPlayerIndex = 0;
        PenaltyCount = 0;
        LastCourtPlayer = null;
        statusMessage = "Click Start Game to begin.";
        GameOver = false;
        winnerMessage = string.Empty;
        LastHumanCard = null;
        LastCpuCard = null;

        DeckService.ResetDeck();
        var dealt = DeckService.DealToPlayers(2);
        Players = new List<Player>
        {
            new Player { Name = "Player 1", Deck = new Queue<Card>(dealt[0]) },
            new Player { Name = "Player 2 (CPU)", Deck = new Queue<Card>(dealt[1]) }
        };

        CurrentPlayerIndex = 0; // left of dealer
        statusMessage = "Player 1 to play.";
        GameOver = false;
        PenaltyActive = false;
        PenaltyPlayerIndex = null;
        StateHasChanged();

        // After UI has rendered, move focus to the Play Card button so Enter can be used
        try
        {
            // yield to allow render
            await Task.Yield();
            await JS.InvokeVoidAsync("focusElement", playButton);
        }
        catch
        {
            // best-effort, ignore JS errors
        }
    }

    private async Task HumanPlay()
    {
        if (GameOver) return;
        if (!IsHumanTurn) return;
        if (Players.Count <= CurrentPlayerIndex) return;

        await PlayWithCooldown(Players[CurrentPlayerIndex]);
        await ContinueTurnsIfNeeded();
    }

    private async Task ContinueTurnsIfNeeded()
    {
        // After human play, let CPU act if it's their turn until human turn returns or game ends
        while (!IsHumanTurn && !GameOver)
        {
            await Task.Delay(350);
            // guard: ensure current player index is valid
            if (Players == null || Players.Count == 0) break;
            if (CurrentPlayerIndex < 0 || CurrentPlayerIndex >= Players.Count) break;
            var current = Players[CurrentPlayerIndex];
            if (current == null) break;
            await PlayWithCooldown(current);
        }
    }

    private async Task PlayWithCooldown(Player player)
    {
        if (!CanPlay) return;
        CanPlay = false;
        // capture player index now so we can decide whether to apply the CPU delay
        var playerIndex = Players?.IndexOf(player) ?? -1;
        try
        {
            await PlayOneCard(player);
        }
        finally
        {
            // enforce a 1 second cooldown before next play is allowed, but only for CPU players
            if (playerIndex != 0)
            {
                await Task.Delay(1000);
            }
            CanPlay = true;
            StateHasChanged();
        }
    }

    private async Task PlayOneCard(Player player)
    {
        await Task.Yield();
        if (GameOver) return;
        if (player is null)
        {
            // nothing to do
            return;
        }
        // determine player index
        var playerIndex = Players.IndexOf(player);
        if (player.Deck == null || player.Deck.Count == 0)
        {
            // player has no cards -> they lose
            EndGameOtherPlayer(player);
            return;
        }

        // Peek at the top card for animation/preview but don't remove it until after animation
        Card? card = null;
        try
        {
            card = player.Deck?.Peek();
        }
        catch
        {
            // fall back to enumerating first element
            card = player.Deck?.FirstOrDefault();
        }

        if (card is null)
        {
            // no card available — defensively advance
            if (Players != null && Players.Count > 0)
                CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
            return;
        }

        // If a player is playing, animate their card moving to center before revealing it in the pile
        if (playerIndex == 1 || playerIndex == 0)
        {
            try
            {
                if (playerIndex == 1)
                {
                    IsAnimatingCpuCard = true;
                    AnimCpuToCenter = false;
                    AnimCpuCardUrl = card.ImageUrl;
                }
                else
                {
                    IsAnimatingPlayerCard = true;
                    AnimPlayerToCenter = false;
                    AnimPlayerCardUrl = card.ImageUrl;
                }
                StateHasChanged();

                // allow the animated element to render
                await Task.Delay(50);

                // start animation to center
                if (playerIndex == 1)
                    AnimCpuToCenter = true;
                else
                    AnimPlayerToCenter = true;
                StateHasChanged();

                // wait for animation to complete (match CSS transition)
                await Task.Delay(650);
            }
            finally
            {
                // clear animation state after the visual transfer and keep last card for UI
                if (playerIndex == 1)
                {
                    IsAnimatingCpuCard = false;
                    AnimCpuToCenter = false;
                    LastCpuCard = card;
                }
                else
                {
                    IsAnimatingPlayerCard = false;
                    AnimPlayerToCenter = false;
                    LastHumanCard = card;
                }
                StateHasChanged();
            }
        }

        // dequeue the card (now that animation/preview is complete) and place it on the pile
        try
        {
            // remove the top card from the player's deck — this should be the same card we peeked
            if (player.Deck != null && player.Deck.Count > 0)
            {
                var dequeued = player.Deck.Dequeue();
                // push the dequeued card into the pile
                Pile.Push(dequeued);
                // record who played this card so the top-card rotation can reflect player side
                LastPlayedByIndex = playerIndex;
                // record last played for display
                if (playerIndex == 0) LastHumanCard = dequeued;
                else if (playerIndex == 1) LastCpuCard = dequeued;
                card = dequeued; // ensure subsequent logic refers to the dequeued card
            }
        }
        catch
        {
            // fallback: if dequeue failed, still push the peeked card
            Pile.Push(card);
        }
        var rank = card.Rank ?? "?";
        var suit = card.Suit ?? "?";
        statusMessage = $"{player.Name} played {rank} of {suit}.";
        if (IsCourt(card))
        {
            // court card played — set new penalty and make the next player the penalized player
            var rnk = card.Rank ?? string.Empty;
            PenaltyCount = CourtPenaltyForRank(rnk);
            LastCourtPlayer = player;
            // next player will be penalized
            var next = (playerIndex + 1) % Players.Count;
            PenaltyActive = true;
            PenaltyPlayerIndex = next;
            CurrentPlayerIndex = next;
            statusMessage = $"{player.Name} played {rnk}. Required cards: {PenaltyCount}";
            StateHasChanged();
            return;
        }

        // If a penalty is active, check whether this player is the penalized player
        if (PenaltyActive && PenaltyPlayerIndex.HasValue)
        {
            if (playerIndex == PenaltyPlayerIndex.Value)
            {
                // penalized player has played one of their required cards
                // if they played a court card above, penalty flow was handled already
                // here it's a non-court card: decrement penalty, and if still >0 they must play again
                PenaltyCount--;
                if (PenaltyCount > 0)
                {
                    // same player must play again
                    CurrentPlayerIndex = playerIndex;
                    statusMessage = $"Required cards remaining: {PenaltyCount}";
                    StateHasChanged();
                    return;
                }

                // Penalty exhausted without a court card — last court player takes the pile
                PenaltyActive = false;
                PenaltyPlayerIndex = null;
                if (LastCourtPlayer != null)
                {
                    // ensure the UI shows the last card that was played before we animate the pile transfer
                    StateHasChanged();
                    await Task.Delay(300);

                    // capture taker and index now. TakePileAsync clears LastCourtPlayer, so
                    // compute the winner label before awaiting the async transfer.
                    var taker = LastCourtPlayer;
                    var idx = taker != null ? Players.IndexOf(taker) : -1;
                    if (idx >= 0) CurrentPlayerIndex = idx;

                    if (taker != null)
                        await TakePileAsync(taker, animate: false);

                    // Use single-digit labels: "Player 1" / "Player 2" when possible
                    string winnerLabel;
                    if (idx == 0) winnerLabel = "Player 1";
                    else if (idx == 1) winnerLabel = "Player 2";
                    else winnerLabel = taker?.Name ?? "Player";
                    statusMessage = $"{winnerLabel} wins the pile.";
                    StateHasChanged();
                    return;
                }
            }
            else
            {
                // not the penalized player's turn — normal advance
                CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
                StateHasChanged();
                return;
            }
        }

    // Normal play and no penalty active -> advance to next player
    CurrentPlayerIndex = (CurrentPlayerIndex + 1) % Players.Count;
        CheckForWin();
        StateHasChanged();
    }

    private void TakePile(Player taker)
    {
        // synchronous transfer used as a fallback
        if (taker == null) return;
        if (taker.Deck == null) taker.Deck = new System.Collections.Generic.Queue<Card>();
        // take all cards from pile (bottom first)
        var cards = Pile.ToArray();
        Array.Reverse(cards); // now bottom -> top
        foreach (var c in cards)
            taker.Deck.Enqueue(c);

        Pile.Clear();
        PenaltyCount = 0;
        LastCourtPlayer = null;
    }

    private async Task TakePileAsync(Player taker, bool animate = true)
    {
        if (taker == null) return;

        // If animation is disabled, perform the synchronous transfer and return.
        if (!animate)
        {
            TakePile(taker);
            StateHasChanged();
            return;
        }

        // prepare animation state: snapshot pile
        var cards = Pile.ToArray();
        AnimPileCards = cards;
        TakePileTargetIndex = Players.IndexOf(taker);
        IsAnimatingTakePile = true;
        StateHasChanged();

        // give the animated element a moment to render, then move it to the player's side
        await Task.Delay(50);
        // choose direction based on target index (0 = left, 1 = right)
        var toLeft = TakePileTargetIndex == 0;
        // set a short flag on the UI via CSS class by keeping TakePileTargetIndex and IsAnimatingTakePile
        StateHasChanged();

        // animate
        await Task.Delay(750);

        // after animation completes, transfer cards into taker's deck
        if (taker.Deck == null) taker.Deck = new System.Collections.Generic.Queue<Card>();
        Array.Reverse(cards); // bottom -> top
        foreach (var c in cards)
            taker.Deck.Enqueue(c);

        // clear pile and reset animation state
        Pile.Clear();
        PenaltyCount = 0;
        LastCourtPlayer = null;
        IsAnimatingTakePile = false;
        TakePileTargetIndex = null;
        AnimPileCards = null;
        StateHasChanged();
    }

    private void EndGameOtherPlayer(Player emptyPlayer)
    {
    // Show the player who ran out of cards as the loser so the UI is explicit
    GameOver = true;
    winnerMessage = $"{emptyPlayer.Name} has lost the game.";
    statusMessage = winnerMessage;
    }

    private void CheckForWin()
    {
        var nonEmpty = Players.Count(p => p.Deck.Count > 0);
        if (nonEmpty == 1)
        {
            var winner = Players.First(p => p.Deck.Count > 0);
            GameOver = true;
            winnerMessage = $"{winner.Name} has won the game!";
            statusMessage = winnerMessage;
        }
    }

    private static bool IsCourt(Card card) => card.Rank is "J" or "Q" or "K" or "A";

    private static int CourtPenaltyForRank(string rank) => rank switch
    {
        "J" => 1,
        "Q" => 2,
        "K" => 3,
        "A" => 4,
        _ => 0
    };

    private string PenaltyBadgeClass(int count)
    {
        return count switch
        {
            1 => "penalty-1",
            2 => "penalty-2",
            3 => "penalty-3",
            4 => "penalty-4",
            _ => "bg-secondary"
        };
    }

    private Card? GetNextCardForPlayer(int playerIndex)
    {
        if (Players == null || playerIndex < 0 || playerIndex >= Players.Count) return null;
        var deck = Players[playerIndex].Deck;
        if (deck == null || deck.Count == 0) return null;
        // Queue<T> doesn't expose Peek in older frameworks? but in .NET it does
        try
        {
            return deck.Peek();
        }
        catch
        {
            // fallback: enumerate first
            return deck.FirstOrDefault();
        }
    }

    private ElementReference startButton;
    private bool prevPlayEnabled = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Move keyboard focus to the Start Game button so pressing Enter starts the game
            try
            {
                await JS.InvokeVoidAsync("focusElement", startButton);
            }
            catch
            {
                // ignore JS errors — focusing is best-effort
            }
        }

        // Determine whether Play Card is enabled now
        var playEnabled = IsHumanTurn && !GameOver && CanPlay;
        if (playEnabled && !prevPlayEnabled)
        {
            // play button has just become available — move focus so Enter will trigger it
            try
            {
                await JS.InvokeVoidAsync("focusElement", playButton);
            }
            catch
            {
                // ignore JS errors
            }
        }
        prevPlayEnabled = playEnabled;
    }
}
